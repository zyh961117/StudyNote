### 异步
- Ajax 异步
- Console 异步（I/O 阻塞）
- 并行线程
- 块是同步运行的，不存在两个函数内的语句交替执行
- JS 一次只能处理一个事件

### 回调
- 嵌套回调与链式回调
- 调用回调时，判断调用次数、时间等，以建立信任
    - 信任问题
        - 调用回调过早
        - 调用回调过晚（或不被调用）
        - 调用回调次数过少或过多
        - 未能传递所需的环境和参数
        - 吞掉可能出现的错误和异常
- 建议：永远异步调用回调

### Promise
- Promise.all([ .. ])接受一个promise数组并返回一个新的promise，这个新promise等待数组中的所有promise完成

-  new Promise( function(resolve,reject){ } );  // 最终调用resolve(..)或者reject(..)，这是这个promise的决议回调

- 信任问题（为什么 Promise 是可信任的）
    - 一定是异步的调用，自动防止调用过早
    - 回调在下一个异步事件点上一定会被触发
    - 一定会调用完成回调和拒绝回调中的一个，设置超时防止永久挂住程序
    - 只接受第一次决议
    - resovle(..) 和 reject(..)只接受单个参数，第一个参数之后的参数会被忽略
    - 在决议前异常错误，则调用拒绝回调。若完成回调中发生异常，会没有被侦听到，因为 p.then 调用本身返回了另一个 promise，这个 promise 会被拒绝。（因为 Promise 一旦决议就不可再改变，原 Promise 不能变）

- 链式流
    - Promise 的行为特性
        - 对 Promise 调用 then 时，会创建并返回一个新的 Promise，我们可以将其链接起来
        - 不管从 then 调用的完成回调返回的值是什么，它都会被自动设置为被链接 Promise 的完成
    - 使链式流程控制可行的 Promise 固有特性
        - 调用 Promise 的 then(..) 会自动创建一个新的 Promise 从调用返回
        - 在完成或拒绝处理函数内部，如果返回一个值或抛出一个异常，新返回的（可链接的）Promise 就相应地决议
        - 如果完成或拒绝处理函数返回一个 Promise，它将会被展开，这样一来，不管它的决议值是什么，都会成为当前 then(..) 返回的链接 Promise 的决议值

- 错误处理
    - try .. catch 无法跨异步操作
    - Promsie 应该添加一个 done(..) 函数，从本质上标识 Promsie 链的结束。done(..) 不会创建和返回 Promise，所以传递给 done(..) 的回调显然不会报告一个并不存在的链接 Promise 的问题。

- Promise 模式
    - Promise.all([ .. ])
        - 从 Promise.all 返回的主 promise 在且仅在所有的成员 promise 都完成后才会完成。如果这些 promise 中有任何一个被拒绝的话，主 Promise.all 就会立即被拒绝，并丢弃来自其他所有 promise 的全部结果。
    - Promise.race([ .. ])
        - 一旦有任何一个 Promise 决议为完成，Promise.race 就会完成；一旦有任何一个 Promise 决议为拒绝，它就会拒绝。
    - 变体
        - none([ .. ])：所有的 Promise 都要被拒绝，即拒绝转化为完成值，反之亦然
        - any([ .. ])：与 all([ .. ]) 类似，但是会忽略拒绝，所以只需要完成一个
        - first([ .. ])：即只要第一个 Promise 完成，它就会忽略后续的任何拒绝和完成。
        - last([ .. ])：类似于 first([ .. ])，但却是只有最后一个完成胜出。

- Promise 局限性
    - 顺序错误处理：很多时候并没有为 Promise 链序列的中间步骤保留的引用。因此，没有这样的引用，你就无法关联错误处理函数来可靠地检查错误
    - 单一值：Promise 只能有一个完成值或一个拒绝理由
    - 单决议：Promise 只能被决议一次（完成或拒绝）
    - 惯性：要将基于回调的代码转化为基于 Promise 的代码
        - 辅助工具 Promise.wrap(..) 并不产出 Promise，它产出的是一个将产生 Promise 的函数
    - 无法取消：一旦创建了一个 Promise 并为其注册了完成和 / 或拒绝处理函数，如果出现某种情况使得这个任务悬而未决的话，你也没有办法从外部停止它的进程。

### 生成器
#### 一种新的执行模式
```JavaScript
function *foo(x,y) {
    return x * y;
}
var it = foo(6, 7);
var res = it.next();
res.value;  // 42
```

- 事实上，我们只是创建了一个迭代器对象，把它赋给了一个变量 it，用于控制生成器 `*foo(..)`。然后调用 `it.next()`，指示生成器 `*foo(..)` 从当前位置开始继续运行，停在下
一个 yield 处或者直到生成器结束。

- 一般来说，需要的 next(..) 调用要比 yield 语句多一个，前面的代码片段有一个 yield 和两个 next(..) 调用。因为，第一个 next(..) 总是启动一个生成器，并运行到第一个 yield 处。不过，是第二个 next(..) 调用完成第一个被暂停的 yield 表达式，第三个 next(..) 调用完成第二个 yield，以此类推。

#### 生成器产生值
- 迭代器是一个定义良好的接口，用于从一个生产者一步步得到一系列值。JavaScript 迭代器的接口，与多数语言类似，就是每次想要从生产者得到下一个值的时候调用 next()。

- next() 调用返回一个对象。这个对象有两个属性：done 是一个 boolean 值，标识迭代器的
完成状态；value 中放置迭代值。

- iterable（可迭代）
    - iterable（可迭代），即指一个包含可以在其值上迭代的迭代器的对象
    - 从 ES6 开始，从一个 iterable 中提取迭代器的方法是：iterable 必须支持一个函数，其名称是专门的 ES6 符号值 Symbol.iterator。调用这个函数时，它会返回一个迭代器。
    ```JavaScript
    var a = [1, 3, 5, 7, 9];
    var it = a[Symbol.iterator]();
    it.next().value; // 1
    it.next().value; // 3
    it.next().value; // 5
    ```

- 停止生成器：调用 it.return(..) 之后，它会立即终止生成器，并会运行 finally 语句。

- 抛出异常：it.throw(..)

#### 生成器委托
前面两个 `it.next()` 调用控制的是 `*bar()`。但当我们发出第三个 `it.next()` 调用时，
`*foo()` 现在启动了，我们现在控制的是 `*foo()` 而不是 `*bar()`。这也是为什么这被称为委
托：`*bar()` 把自己的迭代控制委托给了 `*foo()`。
一旦 it 迭代器控制消耗了整个 `*foo()` 迭代器，it 就会自动转回控制 `*bar()`。

#### 小结
- 生成器可以在运行当中（完全保持其状态）暂停，并且将来再从暂停的地方恢复运行。这种交替的暂停和恢复是合作性的而不是抢占式的。
- yield/next(..) 这一对不只是一种控制机制，实际上也是一种双向消息传递机制。yield .. 表达式本质上是暂停下来等待某个值，接下来的 next(..) 调用会向被暂停的 yield 表达式传回一个值（或者是隐式的 undefined）。
- 在异步控制流程方面，生成器的关键优点是：生成器内部的代码是以自然的同步 / 顺序方式表达任务的一系列步骤。换句话说，生成器为异步代码保持了顺序、同步、阻塞的代码模式，这使得大脑可以更自然地追踪代码，解决了基于回调的异步的两个关键缺陷之一。


### 程序性能
#### Web Worker
- 这是浏览器（即宿主环境）的功能，实际上和 JavaScript 语言本身几乎没什么关系。也就是说，JavaScript 当前并没有任何支持多线程执行的功能。
- 浏览器提供多个 JavaScript 引擎实例，各自运行在自己的线程上，你可以在每个线程上运行不同的程序，程序中每一个这样的独立的多线程部分被称为一个（Web）Worker。这种类型的并行化被称为任务并行，因为其重点在于把程序划分为多个块来并发运行。
- 可以通过 importScripts(..) 向 Worker 加载额外的 JavaScript 脚本：`importScripts( "foo.js", "bar.js" ); `，这些脚本加载是同步的，会阻塞余下 Worker 的执行，直到文件加载和执行完成。

- Web Worker 通常应用于哪些方面呢
    - 处理密集型数学计算
    - 大数据集排序
    - 数据处理（压缩、音频分析、图像处理等）
    - 高流量网络通信

- 在线程之间传递信息
    - 如果要传递一个对象，可以使用结构化克隆算法
    - 还有一个更好的选择，特别是对于大数据集而言，就是使用 Transferable 对象

- 共享 Worker
    - 可以与站点的多个程序实例或多个页面连接
    - 在共享 Worker 内部，必须要处理额外的一个事件："connect"。这个事件为这个特定的连接提供了端口对象。保持多个连接独立的最简单办法就是使用 port 上的闭包

#### 单指令多数据（SIMD）
- 是一种数据并行（data parallelism）方式，与 Web Worker 的任务并行（task parallelism）相对。因为这里的重点实际上不再是把程序逻辑分成并行的块，而是并行处理数据的多个位。

- asm.js
    - 这个标签是指 JavaScript 语言中可以高度优化的一个子集。通过小心避免某些难以优化的机制和模式（垃圾收集、类型强制转换，等等），asm.js 风格的代码可以被 JavaScript 引擎识别并进行特别激进的底层优化。
    - 对 JavaScript 性能影响最大的因素是内存分配、垃圾收集和作用域访问asm.js 对这些问题提出的一个解决方案就是，声明一个更正式的 asm.js“模块”，不要和 ES6 模块混淆。
    - 对一个 asm.js 模块来说，你需要明确地导入一个严格规范的命名空间——规范将之称为stdlib，因为它应该代表所需的标准库——以导入必要的符号，而不是通过词法作用域使用全局的那些符号。

#### 小结
Web Worker 让你可以在独立的线程运行一个 JavaScript 文件（即程序），使用异步事件在
线程之间传递消息。它们非常适用于把长时间的或资源密集型的任务卸载到不同的线程
中，以提高主 UI 线程的响应性。
