- this 提供了隐式传递一个对象引用的方式
- this 既不指向函数自身也不指向函数的词法作用域
- this 记录着函数执行的上下文
    - 调用位置（根据调用栈）
    - 绑定规则
        - 默认绑定
        - 隐式绑定，调用的函数为对象的属性，只有对象引用链的最后一层会影响（_隐式丢失：被隐式绑定的函数会丢失绑定对象_）
        - 显式绑定，call()、apply()、bind()
            - 硬绑定：创建一个函数 A，在内部手动调用 B.call(obj)，这样无论如何调用 A 都会在 obj 上调用 B
        - new 绑定，构造函数调用
        - 优先级：new < 显式 < 隐式 < 默认
    - 例外
        - 将 null、undefined 作为绑定对象时会被忽略，应用默认绑定规则
        - `p.foo = o.foo` 也会导致隐式丢失
        - 软绑定，检查 this 的绑定对象如果是 全局对象或 undefined，则 this 设为默认对象，否则不变
        - 箭头函数，会将调用位置的 this 绑定为函数的 this，且无法被修改（常用于回调函数）

- 对象
    - 属性描述符：value、writable、configurable、enumerable
        - 对象常量，结合 `writable:false` 和 `configurable:false` 就可以创建一个真正的常量属性
        - 禁止对象添加新属性且保留原属性，`Object.preventExtensions( myObject );`
        - 密封：`Object.seal( myObject )`，实际上会调用 preventExtensions 并把所有属性设为 `configurable:false`，但属性的值仍能改变
        - 冻结：`Object.freeze( myObject )`，实际上会调用 seal 并把所有属性设为 `writable:false`
    - [[Get]]、[[Put]] 操作
    - 访问描述符：getter、setter
    - for..in 遍历 key；for..of 遍历 value

- 类
    - JavaScript 实际上没有类
    - 类的机制：类仅仅是一个抽象的表示，必须先实例化后才能对其进行操作
    - JavaScript 不提供 “多重继承”
    - 混入
        - 显式混入
        - 隐式混入（利用 call）

- 原型
    - 属性设置与屏蔽
        - 用 `= ` 创建属性时，原型链上层存在同名属性，若其可写，则在当前原型创建属性并且发生屏蔽；若其只读则忽略赋值语句（严格模式下抛出错误）；若其是一个 setter 则会调用这个 setter，并不会创建属性
        - 隐式屏蔽：`object.a++` 相当于 `object.a = object.a + 1` 会创建属性
    - 模仿类
        - “原型继承”：继承意味着复制操作，而 JS 不会复制对象属性，而是通过 **委托**
        - “构造函数”：new 会劫持所有 **普通函数** 并用构造对象的形式来调用它，使用 new 的构造函数调用会生成 .prototype 和 .constructor 引用，对象的 `.constructor` 会默认指向一个函数，这个函数可以通过对象的 `.prototype`引用。 `Foo.prototype.constructor === Foo`
    - （原型）继承
        - 调用 `a = Object.create(b)` 会凭空创建一个“新”对象 a 并把 a 内部的 [[Prototype]] 关联到指定的对象 b
        - `Bar.ptototype = Object.create( Foo.prototype );`
        - `Object.setPrototypeOf( Bar.prototype, Foo.prototype );`   // ES6
        - 判断委托关联
            - a instanceof Foo  // 适用于对象和函数
            - Foo.prototype.isPrototypeOf( a );  // a 的原型链中是否有 Foo.prototype
            - Object.getPrototypeOf( Bar ) === Foo;
    - 原型链

- ES6 的 class
    - 不再引用杂乱的 .prototype
    - 使用 extends 继承（可以是内置对象类型）
    - 使用 super 来实现相对多态
    - 缺点：如果修改或者替换了父“类”中的方法，那子“类”和所有实例都会受到影响，因为它们在定义时并没有进行复制，只是使用基于 [[Prototype]] 的实时委托
    - class 语法无法定义类成员属性（只能定义方法）
    - 定义同名的属性和方法时，会遭到屏蔽
