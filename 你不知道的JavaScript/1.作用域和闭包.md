- 作用域：负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限（_作用域是根据名称查找变量的一套规则_)

- 对比：动态作用域 & 词法作用域

- LHS、RHS 查询（查询赋值操作的左侧和右侧）   
    - 查找目的是对变量进行赋值时用 LHS 查询，目的是获取变量的值时用 RHS 查询。
    - LHS 查询不到时，会在全局作用域中创建一个具有该名称的变量（非严格模式下）
    - RHS 查询不到时，会抛出异常

- 欺骗词法（在运行时修改词法作用域）
    - eval()
        - 执行动态创建的代码
        - 在严格模式下，eval() 在运行时有其自己的词法作用域，因此无法修改声明所在的作用域
    - with（不推荐使用，严格模式下完全禁止）
        - 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域
    - 会使得引擎的优化无效，降低性能

- 隐藏内部实现
    - 变量和函数私有化
    - 规避同名标识符的冲突(全局命名空间、模块管理)

- 立即执行函数表达式
    - `(function foo(){ .. })()`
    - `(function(){ .. }())`

- let 为变量显式声明块作用域
    - 当有闭包时，会保留外函数的整个作用域，对于不需要保留的函数可以声明在块中，便于垃圾回收
    - 在 ES6 前可以用 try/catch 语句代替

- 变量声明提升
    - 函数声明会提升，函数表达式不会
    - 函数会先被提升，然后提升变量

- 使用闭包的场景：定时器、事件监听器、Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务

- 模块
    - 必须有外部的封榜函数，该函数必须被调用至少一次
    - 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并
且可以访问或者修改私有的状态

- 箭头函数的 this 直接使用当前的词法作用域，也可以用 bind(this)
